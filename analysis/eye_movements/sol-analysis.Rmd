---
title: "SOL-analysis"
author: "Kyle MacDonald"
date: "June 9, 2015"
output: html_document
---

# Data processing, plotting, and analysis script for SOL PEEK data

```{r}
rm(list=ls())
```

## Read in data 

```{r, echo=FALSE, warning=F, message=F}
source("../helpers/libraries_v_3.6.R")
source("../helpers/useful.R")
library(stringr)
```

### Demographics table

```{r}
sol_demo <- read.csv("../../raw_data/sol_demo_all.csv", stringsAsFactors = F)
sol_demo$Sub.Num <- as.character(sol_demo$Sub.Num)
```

### Eye movement data

```{r}
iChart <- read.csv("processed_data/sol-ichart-merged.csv", 
                   check.names=F, stringsAsFactors=F)

iChart$Sub.Num <- as.character(iChart$Sub.Num)
```

## Filter dataset

Filter out participants that should not go into analyses based on exclusionary criteria: a) age, b) didnâ€™t know signs in the task, c) not enough ASL exposure.

```{r}
include <- sol_demo %>%
    filter(include == "yes") %>% 
    select(Sub.Num, include,
           reason_excluded, stimuli,
           age_code, signs_produced)

iChart <- left_join(iChart, include, by = c("Sub.Num", "stimuli"))

iChart <- filter(iChart, include == "yes")
```

Get descriptives: the number of trials for each subject, ages, genders.

```{r}
descriptives <- iChart %>%
    group_by(Sub.Num, Months, Sex, stimuli) %>%
    summarise(Trials = n()) 
```

## Flag C-T and C-D Trials

Datawiz does not tell us which shifts land on a target vs. a disctractor. So we need to use a function that flags each trial as one of the following:

* C-T: center to target
* C-D: center to distractor
* C-C: center to center (child leaves the signer, goes away, and comes back to signer)
* no-shift

```{r}
# apply it to each row in our datase
trial_types <- apply(iChart, 1, trial_type_fun) 

# merge this information back with the iChart
iChart <- cbind(iChart, trial_types)
```

## Filter unknown signs

Create a clean target image variable.

```{r}
targets <- c("juice", "cookie", "cup", "ball", "shoe", "kitty",
             "doll", "teddy", "book", "birdy", "car", "sock")

make_clean_target <- function (target_image, targets) {
    target_img_clean <- targets[str_detect(target_image, targets)]
    return(target_img_clean)
}

iChart$clean_target_img <- unlist(sapply(iChart$Target.Image, 
                                  function (x) make_clean_target(x, targets)))
```

Add unknown signs variable. Taken from sol_demo data frame.

```{r}
ss_unknown_signs <- sol_demo %>% 
    filter(include == "yes") %>% 
    select(Sub.Num, parent_report_unknown_signs)
    
iChart <- left_join(iChart, ss_unknown_signs, by = "Sub.Num")
```

Now we can filter the iChart, removing the "unknown" signs.

```{r}
ss_trials_df <- iChart %>% 
    group_by(Sub.Num, parent_report_unknown_signs) %>% 
    summarise(Trials = n()) 

# flag unknown trials
ss_unknown <- iChart %>% 
    rowwise() %>% 
    mutate(unknown_trial = ifelse(clean_target_img %in% parent_report_unknown_signs,
                                  "unknown_sign", "known_sign")
           ) %>%
    select(Sub.Num, Tr.Num, unknown_trial)

# join this info with the original iChart
iChart <- bind_cols(iChart, select(ss_unknown, unknown_trial))
    
# now filter
iChart <- filter(iChart, unknown_trial == "known_sign")

# check to make sure our filtering worked correctly
post_filter_n <- iChart %>% 
    group_by(Sub.Num) %>% 
    summarise(Trials = n()) %>% 
    select(Trials)

ss_trials_df$post_filter <- post_filter_n$Trials

ss_trials_df <- ss_trials_df %>% 
    mutate(trials_removed = as.integer(Trials) - as.integer(post_filter))
```

Get total number of trials removed because of known signs

```{r}
sum(ss_trials_df$trials_removed)
```

## Remove prescreened out trials

```{r}
ss_prescreened <- iChart %>% 
    group_by(Sub.Num) %>% 
    filter(Prescreen.Notes != "") %>% 
    summarise(num_prescreened = n())

ss_trials_df <- left_join(ss_trials_df, ss_prescreened, by = "Sub.Num")

ss_trials_df <- ss_trials_df %>% 
    mutate(good_trials = Trials - sum(trials_removed, num_prescreened, na.rm=T))

iChart <- filter(iChart, Prescreen.Notes == "")
```

## Remove participants for having too few trials

We define too few trials as less than or equal to 25% of the total number of
trials in the task.

```{r}
total_trials <- 32
trials_cut_point <- total_trials * .25

trials_filter <- ss_trials_df %>% 
    mutate(exclude_few_trials = ifelse(good_trials <= trials_cut_point, 
                                       "exclude", "include")) %>% 
    select(Sub.Num, good_trials, exclude_few_trials)

# merge with iChart
iChart <- left_join(iChart, trials_filter, by = "Sub.Num")

# now filter
iChart <- filter(iChart, exclude_few_trials == "include")
```

## Distribution of trial types

```{r}
iChart %>% group_by(trial_types) %>% summarise(Trials = n())
```


## Get median split by age

```{r}
kids_age_descriptives <- iChart %>%
    filter(age_code == "child") %>%
    summarise(median(Months), 
              max(Months),
              min(Months), 
              sd(Months),
              n_distinct(Sub.Num)) 

# add median split variable to iChart
iChart$age_group <- ifelse(iChart$Months < kids_age_descriptives$`median(Months)`, 
                           "< 29 Months", 
                           ifelse(iChart$Months >= kids_age_descriptives$`median(Months)` & 
                                      iChart$Months <= kids_age_descriptives$`max(Months)`, 
                                  "> 29 Months",
                                  "Adults"))
# check median split
print.data.frame(unique(select(iChart, Sub.Num, Months, age_group)))
```

```{r}
iChart %>% group_by(age_group) %>% summarise(n_distinct(Sub.Num))
```

## Compute statistics

First, we need to process the data, removing prescreened out trials and keeping only those trials on which the child was looking at the signer at F0.

* C: Center
* D: Distractor
* T: Target
* A: Away

includeOffCenter == FALSE -> only include trials child was looking at center at F0

includeOffCenter == TRUE -> include trials child was looking at center, target, or distractor at F0


```{r}
iChart %>% group_by("0", Response) %>% summarise(Trials = n())

# change all trials to "Vanilla" 
iChart$Condition <- "Vanilla"

## define critical onset, change Cs to Ds and everything else to As
iChart <- defineOnsetSOL(iChart, critonset=0, includeOffCenter=FALSE)

## check iChart after setting response (should only have Ds and As)
iChart %>% group_by(Response) %>% summarise(Trials = n())
```

Next, we compute statistics over long window 0-5000 ms. This will allow us to see a 
distribution of RTs, which we will use to determine our analysis window.

```{r, warning=F, message=F}
iChart <- computeStatistics(iChart, startWindow=0, endWindow=5000)

# get analyisis window where 90% of RTs occur for kids
ct.rt <- filter(iChart, trial_types == "C-T", age_group != "Adults")
analysis.window <- quantile(ct.rt$RT, probs=c(0.05, 0.95))

qplot(ct.rt$RT) +
    geom_vline(x=analysis.window[1], col="red", lwd=1.5) +
    geom_vline(x=analysis.window[2], col="red", lwd=1.5) +
    annotate("text", x = 2600, y = 30, 
              label = "Analysis Window \n (%90 RTs)")
```

Compute statistics over analysis window: 0-2700ms. We use 2700 ms because
it is 500 ms longer than the end of our analysis window (2200ms). This allows
us to include trials in which the participant to initiates and completes a 
shift at the very end of the analysis window.

```{r, message=F, warning=F}
iChart <- computeStatistics(iChart, startWindow=0, endWindow=2600)
```

Reject trials with really long RTs and with long gaps. Gaps are defined as 
a sequence of frames when the child is not looking at either picture or 
at the signer.

```{r}
iChart <- filteriChart(iChart, minRT = analysis.window[1], maxRT = analysis.window[2],
                       maxfirstgap=15, maxlonggap=15)
```

## Get mean Accuracy and RT for each participant 

```{r, warning=F, message=F}
acc_ss <- poolData(meanAccuracy(iChart, startWindowAcc=500, endWindowAcc=2100), 
                RejectFirstGap=TRUE,RejectLongestGap=TRUE, 
                RejectRT=FALSE, color=TRUE, dependent="Accuracy", 
                group="", facet="", dodge="", 
                xlab="", ylab= "Proportion\n  Looking\n  to target", 
                paired=TRUE, miny = 0.2, maxy = 0.80, 
                size=13, legend.direction="horizontal", 
                legend.position="bottom", 
                breaks=c(0.25, 0.50, 0.75))

## Compute reaction time for each age group only on C-T trials
rt_ss <- poolData(filter(iChart, trial_types == "C-T"), 
               RejectFirstGap=TRUE, RejectLongestGap=TRUE,
               RejectRT=TRUE, color=FALSE, dependent="RT", group="", 
               facet="", dodge="Response",
               xlab="", ylab="mean RT (ms)", 
               paired=TRUE, 
               miny = 400, maxy=1300, 
               size=13, 
               legend.direction = "horizontal", 
               legend.position="bottom", 
               breaks=c(400, 800, 1200))
```

## Get mean Acc and RT for each participant by condition 

```{r, warning=F, message=F}
acc <- poolData(meanAccuracy(iChart, startWindowAcc=500, endWindowAcc=2100), 
                RejectFirstGap=TRUE,RejectLongestGap=TRUE, 
                RejectRT=FALSE, color=TRUE, dependent="Accuracy", 
                group="age_group", facet="", dodge="", 
                xlab="", ylab= "Proportion\n  Looking\n  to target", 
                paired=TRUE, miny = 0.2, maxy = 0.80, 
                size=13, legend.direction="horizontal", 
                legend.position="bottom", 
                breaks=c(0.25, 0.50, 0.75))

## Compute reaction time for each age group only on C-T trials
rt <- poolData(filter(iChart, trial_types == "C-T"), 
               RejectFirstGap=TRUE, RejectLongestGap=TRUE,
               RejectRT=TRUE, color=FALSE, dependent="RT", group="age_group", 
               facet="", dodge="Response",
               xlab="", ylab="mean RT (ms)", 
               paired=TRUE, 
               miny = 400, maxy=1300, 
               size=13, 
               legend.direction = "horizontal", 
               legend.position="bottom", 
               breaks=c(400, 800, 1200))
```

### Statistics 

Get mean accuracy and rt for each participant

Some munging to get data frame for analysis. Variables needed for each subject: 

* Mean acc 
* Mean rt 
* Signs produced 
* Age 
* Age condition

```{r}
# merge acc/rt van1
ss <- merge(acc_ss, rt_ss, by="Sub.Num")

# merge with demo info
ss <- merge(ss, filter(sol_demo, include=="yes"), by="Sub.Num")

# get age bins
ss_age_bins <- iChart %>%
    select(Sub.Num, age_group, Months) %>%
    distinct() 
    
ss <- merge(ss, ss_age_bins, by="Sub.Num")

# clean up variable names in data frame
names(ss)[names(ss)=="Vanilla"] <- "mean_accuracy"
names(ss)[names(ss)=="Vanilla_D"] <- "mean_ct_rt"
```

Set up filter to just include kids for correlation analyses.

```{r}
ss_kids <- filter(ss, age_group != "Adults")
```

## Acc--Age

```{r}
qplot(Months, mean_accuracy, data = ss_kids) +
    geom_smooth(method = "lm") +
    ylim(0.45, 0.8)

cor.test(ss_kids$mean_accuracy, ss_kids$Months, method = "pearson")
```

## Voc--Age

```{r}
qplot(Months, signs_produced, data = ss_kids) +
    geom_smooth(method = "lm")

cor.test(ss_kids$mean_accuracy, ss_kids$Months, method = "pearson")
```        

## Acc-Voc

```{r}
qplot(signs_produced, mean_accuracy, data = ss_kids) +
    geom_smooth(method = "lm") +
    ylim(0.45, 0.8)

cor.test(ss_kids$mean_accuracy, ss_kids$signs_produced, method = "pearson")
```

## RT--Voc

```{r}
qplot(signs_produced, mean_ct_rt, data= ss_kids) +
    geom_smooth(method = "lm")

cor.test(ss_kids$mean_ct_rt, ss_kids$signs_produced, method = "pearson")
```

## Test difference in Acc/RT between age groups

```{r}
t.test(mean_accuracy ~ age_group, data=ss_kids)
t.test(mean_ct_rt ~ age_group, data=ss_kids)
```


# Plot individual participants performance

```{r, warning=F, message=F, eval=F}
createPlots(iChart, startWindow=0, endWindow=2500, RejectLongestGap=FALSE, 
            RejectFirstGap=FALSE, RejectRT=FALSE, color=TRUE, smooth=400, 
            targetEnd=800, carrier="", targets=c(""), 
            group="age_group",  plotStats="PP", miny = 0.4, maxy=0.95, size=15, 
            legend.direction = "vertical", legend.position=c(0.85, 0.9), 
            breaks=c(0.25, 0.50, 0.75), x.target=0.33)
```

```{r}
ss.et <- read.table("sol-ichart-v1-processed_PP_graphValues_by_subs_0_2500_minRT_33_maxRT_2567_lg_62_fg_34_n_49.txt", header = T)

ss.et$Sub.Num <- as.character(ss.et$Sub.Num)
```

### Some munging to format data for plotting

```{r, warning=F, message=F}
detach("package:reshape", unload=TRUE)

#strip X from header
names(ss.et) <- gsub("X", "", names(ss.et))


ss.et <- left_join(ss.et, ss_kids, by="Sub.Num")

#melt to long form for plotting
ss.et.long <- melt(ss.et, 
                   id.vars=c("Sub.Num", "Condition", 
                             "Months", "signs_produced", 
                             "groupping", "stimuli"),
                   variable.name = "Time.ms",
                   value.name = "accuracy")

#convert sub.num to a factor
ss.et.long <- ss.et.long %>% 
    mutate(Sub.Num = as.factor(Sub.Num), 
           Time.ms = as.numeric(as.character(Time.ms)),
           Months = as.factor(Months),
           accuracy = as.numeric(accuracy))
```


### Exploratory Plots

```{r, message=F, warning=F, fig.height=8, fig.width=10}
# set breaks for x-axis
breaks <- seq(0,2500, by=500)

qplot(data = ss.et.long, x = Time.ms, y = accuracy,
      color=groupping, geom="smooth",
      ylim=c(0.2,1), xlab=c("Time (ms) from noun onset"), 
      ylab=c("Proportion Looking to target")) + 
    geom_hline(yintercept = 0.5, linetype="dashed") +
    scale_x_discrete(breaks = breaks) +
    facet_wrap(Months+signs_produced~Sub.Num, ncol=8) +
    #guides(color=FALSE) +
    geom_vline(xintercept=1200, linetype = "dashed") +
    theme(axis.text.x = element_text(angle = 75, hjust = 1)) +
    theme_bw()
```

